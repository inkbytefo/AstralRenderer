#version 460
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D textures[];
layout(set = 0, binding = 5, rgba32f) uniform writeonly imageCube outputCubemaps[];

layout(push_constant) uniform PushConstants {
    uint inputTextureIndex;
    uint outputTextureIndex;
} pc;

const float PI = 3.14159265359;

vec3 cubeToWorld(ivec3 cubeCoord, vec2 size) {
    vec2 texCoord = (vec2(cubeCoord.xy) + 0.5) / size;
    texCoord = texCoord * 2.0 - 1.0;
    
    vec3 ret;
    switch(cubeCoord.z) {
        case 0: ret = vec3(1.0, -texCoord.y, -texCoord.x); break; // +X
        case 1: ret = vec3(-1.0, -texCoord.y, texCoord.x); break; // -X
        case 2: ret = vec3(texCoord.x, 1.0, texCoord.y); break;   // +Y
        case 3: ret = vec3(texCoord.x, -1.0, -texCoord.y); break;  // -Y
        case 4: ret = vec3(texCoord.x, -texCoord.y, 1.0); break;  // +Z
        case 5: ret = vec3(-texCoord.x, -texCoord.y, -1.0); break; // -Z
    }
    return normalize(ret);
}

void main() {
    ivec3 cubeCoord = ivec3(gl_GlobalInvocationID.xyz);
    ivec2 size = imageSize(outputCubemaps[nonuniformEXT(pc.outputTextureIndex)]);
    
    if (cubeCoord.x >= size.x || cubeCoord.y >= size.y) return;
    
    vec3 worldPos = cubeToWorld(cubeCoord, vec2(size));
    
    // Sample equirectangular texture
    float phi = atan(worldPos.z, worldPos.x);
    float theta = acos(worldPos.y);
    vec2 uv = vec2(phi / (2.0 * PI) + 0.5, theta / PI);
    
    vec3 color = texture(textures[nonuniformEXT(pc.inputTextureIndex)], uv).rgb;
    
    imageStore(outputCubemaps[nonuniformEXT(pc.outputTextureIndex)], cubeCoord, vec4(color, 1.0));
}
